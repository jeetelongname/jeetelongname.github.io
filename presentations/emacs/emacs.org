#+TITLE: Emacs: The Editor For The Next 40 Years
#+OPTIONS: toc:nil reveal_width:1200 reveal_height:1080 num:nil
#+REVEAL_ROOT: ../reveal.js
#+REVEAL_TITLE_SLIDE: <h1>%t</h1><h3>%s</h3><h2>By %A %a</h2><h3><i>I have the software tastes of a 50 year old man</i></h3><p>Press s for speaker notes</p>
#+REVEAL_THEME: black
#+REVEAL_TRANS: slide

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage[top=1cm,left=3cm,right=3cm]{geometry}

* What is emacs
#+begin_notes
Emacs at is core is not a text editor but a lisp vm that specialises in doing
textual work, the current incarnation is (gnu emacs) 36 years old, almost seeing constant
development in that time frame. this has lead it to become one of the most
powerful and unique editors of our time and one that is extremely addicting to
use.
#+end_notes
** A brief history
*** The first emacs
#+begin_notes
the first emacs was a set of macros on top of the TECO editor, this was not
macro's in the keybind or vim sense but more a kind of program to tell the
editor to do, like emacs TECO was an interpreter for its own language, it was
very powerful for its time.

tho let it be known this was not an editor like we have today, it was a line
editor which means you literally had to type commands to move up and down in the
line, a command to insert lines and if you messed up, you started again.
#+end_notes
*** The age of many clones
#+begin_notes
After emacs was taken up many other implementations came up for other platforms,
each with there own quirks and what not. Some of the bigger ones were EINE (EINE
is not emacs), ZWEI (ZWEI was EINE initially), most curiosly James Gosling (as
in the guy who invented JAVA and cursed this industry) also wrote his own
implementation of emacs named after himself.

to cut a long story short Gnu emacs won out over all of them in no small part to
the fact that UniPress (a company Gosling sold his emacs to) was charging like
$300 for a licenece while also banking on the fact that a community run fork
would die quickly, Oh how wrong they were.
#+end_notes
*** The age of acceptance
#+begin_notes
After that small spat gnu emacs became the standard unix text editor and with
the only other noticable fork being Lucide Emacs (being developed by Lucid inc)
it was based on gnu emacs 19 but diverged and then slowly died. (this was in
response to a slowing down of gnu emacs developent).

Now its the only real Emacs left with other programs being based on or being
inspired by emacs to some degree.
#+end_notes

* How has emacs has survived this long?
#+begin_notes
In other words why has it not gone the way of netbeans after more modern editors
came to the table?
#+end_notes
** Cults help
#+begin_notes
Emacs has an almost cult like following, its hard to describe but in a word
emacs is addicting for reasons ill expand on

but there are people out there who use emacs for everything (some for good reason, some for
less).
things like,
#+end_notes

#+attr_reveal: :frag (roll-in)
- emacs terminals
- emacs shells
- emacs browsers
- emacs window managers
- emacs web browsers (as in they embed a full web browser)
- emacs init system...

** For a very long time its was the most advanced editor of its time
#+begin_notes
a version of Emacs has been around since the 1976, most people in this room were either not
born or playing with rattles or Atari's
In all that time its only grown in power, spear heading a lot of early concepts
that then get reinvented later to become mainstream (usually becoming less
powerful in the process). things like jumping to errors, early ide / shell
interfaces, in editor debugger interfaces and so on all have a history of being
written in emacs lisp first.

also for the people who used latex editors in the early 90's a lot of those
features came from emacs's latex-mode and later a plugin called auxtex (a plugin
I use to this day and can say is still kinda best in class)
#+end_notes

*** also in some places, still kinda is...
#+begin_notes
Things like an infinite clipboard which instead of clobbering the last item its
pushed onto a stack, which can then be traversed, this is really bloody useful
for when you need to find that one snippet you cut over 10 motions ago.

plus if you want to get into certain languages such as common lisp,
clojour and racket the emacs experience is very hard to beat.
#+end_notes

** Hack ability
#+begin_notes
emacs has a very low barrier of entry to get working on it, unlike a lot of
editors today the smallest unit of extension is not a package or project, but a
function in most cases though most of the time you can configure it with
small tweaks, setting variables and whatnot.

Emacs is not structured like editors today, as in there is little structure too
it, even packages are more a collection of forms using a convention rather than
some strict heirarchy of statements talking through an api.

this means that pretty much everything is up for grabs (except maybe some c
special forms). This leads into the next couple of points where most parts of
the editor are written emacs lisp and every function / special form can be
"advised" at runtime. its similar to python decorators in the way they
manipulate a function in some certain way but with the key
difference is that they don't need to be called where  the function is defined. this
means a user can edit any function to act in the exact way they want and it will
be run like the user wants every time its called, this is extremely powerful.
#+end_notes
#+ATTR_REVEAL: :frag (roll-in)
- It has a low barrier to extension
- Most if not all things can be extended / modified
- Most things are implemented in emacs lisp (meaning most things are fungible by
  the user)
- you can advise functions to do exactly what you want
- and so much more...
** Its extremely introspect able
#+begin_notes
every function, variable and special form is documented and easily accessible and
checked, either by pressing a key-bind on the form or by searching for it in a
help lookup. this again makes it way to easy to hack on it as there are entire
weeks I never need to look something up. add to that a very strong documentation
culture and I can really look into the guts of how my editor works and actually
fiddle with it.
#+end_notes
** the ecosystem
#+begin_notes
all of this allows for an extremely interesting ecosystem to pop up, as its easy
to iterate on designs, interesting UI concepts can and do pop up all over the
place, some quick examples include
#+end_notes
*** its git interface
*** org mode
*** the mail client
* Why it will outlast current editors
** Its pragmatic but not stagnant
#+begin_notes
Emacs is slower to pick up trends but this is not really a problem as
the community can implement it
when it is implemented its usually vetted and documented very well and in a way
other people can build off it.

As time marches on it also plans to add lsp support (the thing that makes
vscodes completion go brrr) and tree sitter support (both of which have been
implemented out side of emacs core and work really well).
#+end_notes
** Its very backwards compatible!
#+begin_notes
When a new feature is added it usually sticks around for a very long time. this
means that configs need minimal tweaking, sometimes none, this leads to people
using the same config for decades without having to edit much. this is really
good because...
#+end_notes
** Its got a community with no where else to go...
#+begin_notes
Emacs is pretty much unique in this space, no where else can you find a lisp
machine that self documents as you edit it on the fly. its old and wise and with
a community of addicts that will happily maintain and update it as time goes on.
#+end_notes

* Thanks!
